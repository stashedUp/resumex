{"remainingRequest":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/ngx-page-scroll/src/ngx-page-scroll.service.js","dependencies":[{"path":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/ngx-page-scroll/src/ngx-page-scroll.service.js","mtime":1509371973000},{"path":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/cache-loader/dist/cjs.js","mtime":1533011384028},{"path":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Injectable, Optional, SkipSelf, isDevMode } from '@angular/core';\nimport { PageScrollConfig } from './ngx-page-scroll-config';\nimport { PageScrollUtilService as Util } from './ngx-page-scroll-util.service';\nvar PageScrollService = /*@__PURE__*/ (function () {\n    function PageScrollService() {\n        var _this = this;\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: function (event, pageScrollInstance) {\n                if (!pageScrollInstance.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                var shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (PageScrollConfig._interruptKeys.indexOf(event.keyCode) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.scrollingViews.some(function (scrollingView) { return scrollingView.contains(event.target); })) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    _this.stopAll(pageScrollInstance.namespace);\n                }\n            }\n        };\n        if (PageScrollService.instanceCounter > 0 &&\n            (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode()))) {\n            console.warn('An instance of PageScrollService already exists, usually ' +\n                'including one provider should be enough, so double check.');\n        }\n        PageScrollService.instanceCounter++;\n    }\n    PageScrollService.prototype.stopInternal = function (interrupted, pageScrollInstance) {\n        var index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     *\n     * @param pageScrollInstance\n     */\n    PageScrollService.prototype.start = function (pageScrollInstance) {\n        var _this = this;\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.namespace);\n        if (pageScrollInstance.scrollingViews === null || pageScrollInstance.scrollingViews.length === 0) {\n            // No scrollingViews specified, thus we can't animate anything\n            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollingViews specified, this ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        var startScrollPositionFound = false;\n        // Reset start scroll position to 0. If any of the scrollingViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollingViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.scrollingViews.forEach(function (scrollingView) {\n            if (Util.isUndefinedOrNull(scrollingView)) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            var scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n            }\n        });\n        var pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        var scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        var allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < PageScrollConfig._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.duration;\n        // Maybe we need to pay attention to the speed option?\n        if (!Util.isUndefinedOrNull(pageScrollInstance.speed) && Util.isUndefinedOrNull(pageScrollInstance.duration)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration = Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        var tooShortInterval = pageScrollInstance.executionDuration <= PageScrollConfig._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.interruptible ||\n            (Util.isUndefinedOrNull(pageScrollInstance.interruptible) && PageScrollConfig.defaultInterruptible)) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval(function (_pageScrollInstance) {\n            // Take the current time\n            var currentTime = new Date().getTime();\n            // Determine the new scroll position\n            var newScrollPosition;\n            var stopNow = false;\n            if (_pageScrollInstance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = _pageScrollInstance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(_pageScrollInstance.easingLogic.ease(currentTime - _pageScrollInstance.startTime, _pageScrollInstance.startScrollPosition, _pageScrollInstance.distanceToScroll, _pageScrollInstance.executionDuration));\n            }\n            // Set the new scrollPosition to all scrollingViews elements\n            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollingViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                _this.stopInternal(false, _pageScrollInstance);\n            }\n        }, PageScrollConfig._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    };\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     *\n     * @param namespace\n     * @returns {boolean}\n     */\n    PageScrollService.prototype.stopAll = function (namespace) {\n        if (this.runningInstances.length > 0) {\n            var stoppedSome = false;\n            for (var i = 0; i < this.runningInstances.length; ++i) {\n                var pageScrollInstance = this.runningInstances[i];\n                if (Util.isUndefinedOrNull(namespace) || namespace.length === 0 ||\n                    pageScrollInstance.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    };\n    PageScrollService.prototype.stop = function (pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    };\n    PageScrollService.instanceCounter = 0;\n    return PageScrollService;\n}());\nexport { PageScrollService };\n/* singleton pattern taken from https://github.com/angular/angular/issues/13854 */\nexport function NgxPageScrollServiceProviderFactory(parentDispatcher) {\n    return parentDispatcher || new PageScrollService();\n}\nexport var NgxPageScrollServiceProvider = {\n    provide: PageScrollService,\n    deps: [[new Optional(), new SkipSelf(), PageScrollService]],\n    useFactory: NgxPageScrollServiceProviderFactory\n};\n",null]}