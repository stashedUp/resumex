{"remainingRequest":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/ngx-page-scroll/src/ngx-page-scroll-instance.js","dependencies":[{"path":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/ngx-page-scroll/src/ngx-page-scroll-instance.js","mtime":1509371973000},{"path":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/cache-loader/dist/cjs.js","mtime":1533011384028},{"path":"/Users/warrenveerasingam/KeplersBox/ResumeX/resumex-fe/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { EventEmitter, isDevMode } from '@angular/core';\nimport { PageScrollConfig } from './ngx-page-scroll-config';\nimport { PageScrollUtilService as Util } from './ngx-page-scroll-util.service';\n/**\n * Represents a scrolling action\n */\nvar PageScrollInstance = /*@__PURE__*/ (function () {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollInstance#simpleInstance}\n     *      {@link PageScrollInstance#newInstance}\n     * @param namespace\n     * @param document\n     */\n    function PageScrollInstance(namespace, document) {\n        /**\n         * These properties will be set during instance construction and default to their defaults from PageScrollConfig\n         */\n        /* A namespace to \"group\" scroll animations together and stopping some does not stop others */\n        this._namespace = PageScrollConfig._defaultNamespace;\n        /* Whether we scroll vertically (true) or horizontally (false) */\n        this._verticalScrolling = PageScrollConfig.defaultIsVerticalScrolling;\n        /* Offset in px that the animation should stop above that target element */\n        this._offset = PageScrollConfig.defaultScrollOffset;\n        /* Duration in milliseconds the scroll animation should last */\n        this._duration = PageScrollConfig.defaultDuration;\n        /* Easing function to manipulate the scrollTop/scrollLeft value over time */\n        this._easingLogic = PageScrollConfig.defaultEasingLogic;\n        /* Boolean whether the scroll animation should stop on user interruption or not */\n        this._interruptible = PageScrollConfig.defaultInterruptible;\n        /* Whether the advanded offset calculation for inline scrolling should be used */\n        this._advancedInlineOffsetCalculation = PageScrollConfig.defaultAdvancedInlineOffsetCalculation;\n        /* Event emitter to notify the world about the scrolling */\n        this._pageScrollFinish = new EventEmitter();\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this._startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this._interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n         able to clear it on animation end*/\n        this._timer = null;\n        this._namespace = namespace;\n        this.document = document;\n    }\n    /*\n     * Factory methods for instance creation\n     */\n    PageScrollInstance.simpleInstance = function (document, scrollTarget, namespace) {\n        return PageScrollInstance.newInstance({\n            document: document,\n            scrollTarget: scrollTarget,\n            namespace: namespace\n        });\n    };\n    PageScrollInstance.newInstance = function (options) {\n        if (Util.isUndefinedOrNull(options.namespace) || options.namespace.length <= 0) {\n            options.namespace = PageScrollConfig._defaultNamespace;\n        }\n        var pageScrollInstance = new PageScrollInstance(options.namespace, document);\n        if (Util.isUndefinedOrNull(options.scrollingViews) || options.scrollingViews.length === 0) {\n            pageScrollInstance._isInlineScrolling = false;\n            pageScrollInstance._scrollingViews = [document.documentElement, document.body, document.body.parentNode];\n        }\n        else {\n            pageScrollInstance._isInlineScrolling = true;\n            pageScrollInstance._scrollingViews = options.scrollingViews;\n        }\n        pageScrollInstance._scrollTarget = options.scrollTarget;\n        if (!Util.isUndefinedOrNull(options.verticalScrolling)) {\n            pageScrollInstance._verticalScrolling = options.verticalScrolling;\n        }\n        if (!Util.isUndefinedOrNull(options.pageScrollOffset)) {\n            pageScrollInstance._offset = options.pageScrollOffset;\n        }\n        if (!Util.isUndefinedOrNull(options.pageScrollEasingLogic)) {\n            pageScrollInstance._easingLogic = options.pageScrollEasingLogic;\n        }\n        if (Util.isUndefinedOrNull(options.pageScrollDuration) && !Util.isUndefinedOrNull(options.pageScrollSpeed)) {\n            // No duration specified in the options, only in this case we use the speed option when present\n            pageScrollInstance._speed = options.pageScrollSpeed;\n            pageScrollInstance._duration = undefined;\n        }\n        else if (!Util.isUndefinedOrNull(options.pageScrollDuration)) {\n            pageScrollInstance._duration = options.pageScrollDuration;\n        }\n        if (!Util.isUndefinedOrNull(options.pageScrollFinishListener)) {\n            pageScrollInstance._pageScrollFinish = options.pageScrollFinishListener;\n        }\n        pageScrollInstance._interruptible = options.pageScrollInterruptible ||\n            (Util.isUndefinedOrNull(options.pageScrollInterruptible) && PageScrollConfig.defaultInterruptible);\n        pageScrollInstance._advancedInlineOffsetCalculation = options.advancedInlineOffsetCalculation ||\n            (Util.isUndefinedOrNull(options.advancedInlineOffsetCalculation) &&\n                PageScrollConfig.defaultAdvancedInlineOffsetCalculation);\n        return pageScrollInstance;\n    };\n    PageScrollInstance.prototype.getScrollPropertyValue = function (scrollingView) {\n        if (!this.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    };\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     * @returns {HTMLElement}\n     */\n    PageScrollInstance.prototype.extractScrollTargetPosition = function () {\n        var scrollTargetElement;\n        if (typeof this._scrollTarget === 'string') {\n            var targetSelector = this._scrollTarget;\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                scrollTargetElement = this.document.getElementById(targetSelector.substr(1));\n            }\n            else {\n                scrollTargetElement = this.document.querySelector(targetSelector);\n            }\n        }\n        else {\n            scrollTargetElement = this._scrollTarget;\n        }\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this._isInlineScrolling) {\n            var position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n            if (this._advancedInlineOffsetCalculation && this.scrollingViews.length === 1) {\n                var accumulatedParentsPos = { top: 0, left: 0 };\n                // not named window to make sure we're not getting the global window variable by accident\n                var theWindow = scrollTargetElement.ownerDocument.defaultView;\n                var parentFound = false;\n                // Start parent is the immediate parent\n                var parent_1 = scrollTargetElement.parentElement;\n                // Iterate upwards all parents\n                while (!parentFound && !Util.isUndefinedOrNull(parent_1)) {\n                    if (theWindow.getComputedStyle(parent_1).getPropertyValue('position') === 'relative') {\n                        accumulatedParentsPos.top += parent_1.offsetTop;\n                        accumulatedParentsPos.left += parent_1.offsetLeft;\n                    }\n                    // Next iteration\n                    parent_1 = parent_1.parentElement;\n                    parentFound = parent_1 === this.scrollingViews[0];\n                }\n                if (parentFound) {\n                    // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                    position.top += accumulatedParentsPos.top;\n                    position.left += accumulatedParentsPos.left;\n                }\n                else {\n                    if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                        console.warn('Unable to find nested scrolling targets parent!');\n                    }\n                }\n            }\n            return position;\n        }\n        return Util.extractElementPosition(this.document, scrollTargetElement);\n    };\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     *\n     * @returns {number}\n     */\n    PageScrollInstance.prototype.getCurrentOffset = function () {\n        return this._offset;\n    };\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollingViews to the provided value\n     * @param position\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollingViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    PageScrollInstance.prototype.setScrollPosition = function (position) {\n        var _this = this;\n        if (PageScrollConfig._logLevel >= 5 && isDevMode()) {\n            console.warn('Scroll Position: ' + position);\n        }\n        // Set the new scrollTop/scrollLeft to all scrollingViews elements\n        return this.scrollingViews.reduce(function (oneAlreadyWorked, scrollingView) {\n            var startScrollPropertyValue = _this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && !Util.isUndefinedOrNull(startScrollPropertyValue)) {\n                var scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                var isSmallMovement = scrollDistance < PageScrollConfig._minScrollDistance;\n                if (!_this.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true of setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(_this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }, false);\n    };\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    PageScrollInstance.prototype.fireEvent = function (value) {\n        if (this._pageScrollFinish) {\n            this._pageScrollFinish.emit(value);\n        }\n    };\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     *\n     * @param interruptReporter\n     */\n    PageScrollInstance.prototype.attachInterruptListeners = function (interruptReporter) {\n        var _this = this;\n        if (this._interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this._interruptListener = function (event) {\n            interruptReporter.report(event, _this);\n        };\n        PageScrollConfig._interruptEvents.forEach(function (event) { return _this.document.body.addEventListener(event, _this._interruptListener); });\n        this._interruptListenersAttached = true;\n    };\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    PageScrollInstance.prototype.detachInterruptListeners = function () {\n        var _this = this;\n        PageScrollConfig._interruptEvents.forEach(function (event) { return _this.document.body.removeEventListener(event, _this._interruptListener); });\n        this._interruptListenersAttached = false;\n    };\n    Object.defineProperty(PageScrollInstance.prototype, \"namespace\", {\n        get: function () {\n            return this._namespace;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"scrollTarget\", {\n        get: function () {\n            return this._scrollTarget;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"verticalScrolling\", {\n        get: function () {\n            return this._verticalScrolling;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"scrollingViews\", {\n        get: function () {\n            return this._scrollingViews;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"startScrollPosition\", {\n        get: function () {\n            return this._startScrollPosition;\n        },\n        set: function (value) {\n            this._startScrollPosition = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"targetScrollPosition\", {\n        get: function () {\n            return this._targetScrollPosition;\n        },\n        set: function (value) {\n            this._targetScrollPosition = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"distanceToScroll\", {\n        get: function () {\n            return this._distanceToScroll;\n        },\n        set: function (value) {\n            this._distanceToScroll = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"executionDuration\", {\n        get: function () {\n            return this._executionDuration;\n        },\n        set: function (value) {\n            this._executionDuration = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"duration\", {\n        get: function () {\n            return this._duration;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"speed\", {\n        get: function () {\n            return this._speed;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"easingLogic\", {\n        get: function () {\n            return this._easingLogic;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"interruptible\", {\n        get: function () {\n            return this._interruptible;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"startTime\", {\n        get: function () {\n            return this._startTime;\n        },\n        set: function (value) {\n            this._startTime = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"endTime\", {\n        get: function () {\n            return this._endTime;\n        },\n        set: function (value) {\n            this._endTime = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"timer\", {\n        get: function () {\n            return this._timer;\n        },\n        set: function (value) {\n            this._timer = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PageScrollInstance.prototype, \"interruptListenersAttached\", {\n        get: function () {\n            return this._interruptListenersAttached;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PageScrollInstance;\n}());\nexport { PageScrollInstance };\n",null]}